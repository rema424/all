# APP-ENGINE-GO112

## 準備

- Google Account の作成
- GCP プロジェクトの作成
- Cloud SDK のセットアップ

### Google Account の作成

https://accounts.google.com/signup

### GCP プロジェクトの作成

https://console.cloud.google.com/projectselector2/home/dashboard

### Cloud SDK のセットアップ

```sh
curl https://sdk.cloud.google.com | bash
exec -l $SHELL
gcloud init
```

### 課金プロジェクトのリンク

https://console.cloud.google.com/projectselector2/billing

### App Engine のセットアップ

```sh
gcloud components update
gcloud config list
gcloud projects describe [YOUR_PROJECT_ID]
gcloud app create --project=[YOUR_PROJECT_ID]
gcloud components install app-engine-go
```

### 各種操作

```sh
# ローカル実行
go run appengine/default/main.go

# デプロイ
gcloud app deploy appengine/default/app.yaml
```

### 逆引き DDD

- トランザクション（データの整合性）はどこで担保する？
- データストアを複数跨ぐ処理はどうする？（RDB とオブジェクトストレージ）

# 【Go】やはりお前らの DDD レイヤードアーキテクチャは間違っている

## はじめに

タイトルは半分釣りです。ごめんなさい。

ただ聞いてください。残りの半分は本当に問題提起です。

実際の問題提起は「お前らの DDD レイヤードアーキテクチャ**についての記事**は間違っている」ですけど。

## 問題提起？

「ドメイン駆動設計」ですよね？？？

にも関わらず「DDD で実装してみました」系の記事でドメインに着目して解説してる記事少なくないですか？？？

ディレクトリ構成だったり依存の方向性だったり、技術に注目した記事ばかりじゃないですか？？？

それじゃ「ドメイン駆動」じゃなくて「技術駆動」じゃないですか？？？

何かしらの業務を仮定した上でそれをどのようにプログラムに落とし込んでいくか、その時ディレクトリ構成はどうなるか。これが本当に見つけたいことなのではないでしょうか。

これが問題提起です。

ということで、言い出しっぺの法則でこの記事の残りの部分ではシステム化対象とする業務を中心に添えつつ DDD のレイヤードアーキテクチャについて考えて行きたいと思います。

題材とするのは**小売業務**で、開発に用いる言語は Go です。

## 業務の仮定

システム化対象とする仮定の業務を次に示します。

> 電話「プルルルル。プルルルル。ガチャ」
>
> 店員「はい。〇〇ストアです。」
>
> 客「すみません。商品を購入したいのですが、○○ と □□ と △△ の在庫って今ありますか？」
>
> 店員「確認しますね。少々お待ちください。」
>
> （店員確認中...）
>
> 店員「お待たせしました。全て在庫ございますよ。ただ □□ と △△ は残りわずかで店内に並べてあるものが最後となっています。」
>
> 客「おお！ぜひ購入したいです！30 分後にお店に伺うのでお取り置きしてもらうことって可能ですか？？」
>
> 店員「承りますよ。それぞれ何個ずつお取り置きしますか？」
>
> 客「それぞれ 2 個ずつお願いします！」
>
> 店員「かしこまりました。ただいま在庫を確保しますので少々お待ちください。」
>
> （店員、陳列棚と倉庫から商品を確保してレジ裏に運び中...）
>
> 店員「お待たせしました。在庫の確保ができたのでお取り置きしておきます。お名前と電話番号を伺ってもよろしいでしょうか。」
>
> 客「はい！名前が ◇◇◇◇ で、電話番号が xxx-xxxx-xxxx です！」
>
> 店員「それではお待ちしております。なお、□□ と △△ は人気商品となっていますので、今から 1 時間以内に受け取りにいらっしゃらない場合はお取り置きをやめて店頭に再度陳列しますのでご了承ください。」
>
> 客「わかりました！それでは 30 分後に伺います！よろしくお願いします！」
>
> 〜 完 〜

以上が今回題材とする小売業務の内容です。

上記のシチュエーションではまだ売買は成立していないので、注文や購入ではなく**予約**になるかと思います。

## オブジェクトの抽出

それでは次にオブジェクトになりそうなものを抽出してみます。

- 顧客（customer）
- 店員（employee）
- 商品（item）
- 在庫（stock）
- 注文（order）
- 注文詳細（order_detail）
- 予約（reservation）

「商品」と「在庫」については補足が必要です。ここでは、商品は「概念としての商品」を指していて、在庫は「実体としての商品」を指しています。例を挙げると、たとえば Mac Book Pro の予約をする場合、購入側は概念（モデル）としての Mac Book Pro を指して予約し、販売側はシリアルナンバーのついた個別具体の Mac Book Pro の在庫を確保します。言い方を変えると、購入側は「このシリアルナンバーの Mac Book Pro を下さい」のように個別具体の商品を指して予約はしません。（なお、これは新品市場での話であって、中古市場だと個別具体を指して予約や注文をすることが一般的かと思います。）DDD においては、このような概念としてのオブジェクトを「値オブジェクト」、個別具体のオブジェクトを「エンティティ」と名付けて区別しています。RDB の設計においては、概念の方を「商品マスタ」、実体の方を「商品テーブル」と名付けて区別しているプロジェクトもあるようです。本記事においては概念の方を「商品」、実体の方を「在庫」と呼んで扱っていきます。

抽出したオブジェクトをコードにしてみます。

```go
type Customer struct {
	ID          int
	Name        string
	PhoneNumber int
}

type Employee struct {
	ID   int
	Name string
}

type Item struct {
	ID    int
	Name  string
	Price int
}

type Items []Item

type Order struct {
	ID           int
	OrderDetails OrderDetails
	Customer     Customer
	Employee     Employee
	CreatedAt    time.Time
}

type OrderDetail struct {
	OrderID  int
	Item     Item
	Quantity int
}

type OrderDetails []OrderDetail

type Stock struct {
	ID     int
	Status StockStatus
	Item   Item
}

type Stocks []Stock

type StockStatus int

const (
	StockStatusOnSale StockStatus = 1
	StockStatusReserved StockStatus = 2
	StockStatusSoldOut StockStatus = 3
)

type Reservation struct {
	ID       int
	OrderID  int
	Stocks   Stocks
	ExpireAt time.Time
}
```

## 業務におけるコアオブジェクトの抽出

さて、オブジェクトの一覧化ができたとろこで、次は今回の対象業務におけるコアオブジェクトを特定していきます。（ここで言うコアオブジェクトというのは私特有の表現なので注意が必要です。）

対象業務を一言で表すと次のいずれかになるかと思います。

- 客が商品を注文する
- 従業員が在庫を取り置く
- 客が商品の予約をとる

まだまだ表現の仕方はいろいろあるかと思いますが、一旦この程度にしておきます。

それではここで注目すべきは「オブジェクト」です。中学生のころ英語の授業で SVO （Subject・Verb・Object、主語・動詞・目的語）というのをみなさん学習されたかと思います。この SVO を今挙げた業務に当てはめると次のようになります。

- 客が商品の注文する（S:客、V:注文する、O:商品）
- 従業員が在庫を取り置く（S:従業員、V:取り置く、O:在庫）
- 客が商品の予約をとる（S:客、V:とる、O:予約）

SVO のうち Object を取り出すと「商品」「在庫」「予約」のいずれかとなります。一方で「客」や「従業員」はこの文脈においては Subject であって Object ではありません。よって、もしオブジェクト指向的にプログラムをするのであれば、今回は商品・在庫・予約のいずれかをコアオブジェクトとして業務を組み立てて行くことになります。Subject である客や従業員は中心になりません。

（ちなみに予約に関しては「Reserve（予約する）」とそれ自体を動詞として捉えたり、「Make a reservation（予約をする）」のように目的語として捉えたりと両方の表現があるので難しいところですね。どちらで捉えるかをチーム内で共通言語として決めるのが良さそうです。）

本記事においては「客が商品の予約をとる」の表現を採用してプログラムを作っていくことにします。「予約をキャンセルする」のように業務を拡張しやすそうなことから「予約」をコアオブジェクトとして扱うことにします。

コアオブジェクトが予約になったので、作成するプログラムは「予約サービス」と名付けることにします。

## リクエストの入口

実際にプログラムの実装に入っていきます。まず最初にリクエストの入口になる部分を考えてみます。リクエストの入口で必要となる処理は作ろうとしているシステムの形態によって違ってきます。コマンドラインツールにするならパラメータはコマンドライン引数や環境変数で渡ってきますし、Web ツールにするならパラメータは HTTP リクエストで渡ってくることになります（厳密には HTTP 以外のプロトコルの場合もありえます）。このようなリクエストの解釈の部分はシステムに依存する部分であって、実際の業務の関心事ではありません。よって、業務ロジックとリクエスト解釈ロジックは別々に記述して管理していきます。

このようなリクエスト解釈の部分は Adapter や Application Logic などと呼ばれます。

本記事においては Web API としてリクエストを受け付けるような実装にします。HTTP リクエストの解釈を容易に実施できるようにするため Web フレームワークを利用して実装していきます。採用するフレームワークは echo です。

まずはリクエストパラメータのインタフェースについて考えます。今回は前述した業務における電話口での注文内容がリクエストになります。予約したい商品と個数、客の名前と電話番号、そして対応する従業員の情報です。従業員の情報は前もって DB に登録されていると仮定すると、リクエストパラメータのサンプルは次のようになります。

```json
{
  "orderDetails": [
    {
      "itemId": 901,
      "quantity": 2
    },
    {
      "itemId": 902,
      "quantity": 2
    },
    {
      "itemId": 903,
      "quantity": 2
    }
  ],
  "customer": {
    "name": "Alice",
    "phoneNumber": "XXX-XXXX-XXXX"
  },
  "employee": {
    "id": 101
  }
}
```

`reservation_controller.go`

```

```
